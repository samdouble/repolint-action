{"version":3,"sources":["../src/cli.ts","../src/rules/file-contains.ts","../src/utils/files.ts","../src/utils/types.ts","../src/rules/file-exists.ts","../src/rules/file-forbidden.ts","../src/rules/file-not-contains.ts","../src/rules/github-actions-timeout-minutes.ts","../src/rules/license-exists.ts","../src/rules/pyproject-dependencies-alphabetical-order.ts","../src/rules/readme-exists.ts","../src/rules/requirements-txt-dependencies-alphabetical-order.ts","../src/utils/python/requirements.ts","../src/rulesMapper.ts","../src/utils/context.ts","../src/utils/config.ts","../src/rules/index.ts","../src/index.ts"],"sourcesContent":["#!/usr/bin/env node\n\nimport { Command } from 'commander';\nimport { readFileSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { getOctokit } from '@actions/github';\nimport { getConfig, run } from './index';\n\nconst packageJson = JSON.parse(\n  readFileSync(join(__dirname, '../package.json'), 'utf-8'),\n);\n\nconst program = new Command();\n\nprogram\n  .name('repofmt')\n  .description('A CLI tool that checks consistency across repositories')\n  .version(packageJson.version);\n\nprogram\n  .command('run')\n  .description('Run repofmt checks against your repositories')\n  .option('--config <path>', 'path to config file')\n  .option('--token <token>', 'GitHub token (can also use GITHUB_TOKEN env var)')\n  .action(async (options) => {\n    console.log('Running repofmt...');\n\n    let config;\n    try {\n      config = await getConfig(options.config);\n    } catch (error) {\n      console.error(\n        `Configuration error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n      );\n      process.exit(1);\n    }\n\n    const token = options.token ?? process.env.GITHUB_TOKEN;\n    if (!token) {\n      console.error('GitHub token is required. Use --token or set GITHUB_TOKEN environment variable');\n      process.exit(1);\n    }\n\n    const octokit = getOctokit(token);\n\n    try {\n      const results = await run(octokit, config);\n\n      let totalErrors = 0;\n      let totalWarnings = 0;\n\n      for (const repoResult of results) {\n        console.log(`\\n${repoResult.repository}`);\n\n        for (const { rule, errors, warnings } of repoResult.results) {\n          for (const error of errors ?? []) {\n            console.log(`  ❌ ${rule}: ${error}`);\n            totalErrors++;\n          }\n          for (const warning of warnings ?? []) {\n            console.log(`  ⚠️ ${rule}: ${warning}`);\n            totalWarnings++;\n          }\n        }\n      }\n\n      console.log(`${totalErrors} error${totalErrors > 1 ? 's' : ''}, ${totalWarnings} warning${totalWarnings > 1 ? 's' : ''}`);\n\n      process.exit(totalErrors > 0 ? 1 : 0);\n    } catch (error) {\n      console.error(`Error: ${error instanceof Error ? error.message : 'Unknown error'}`);\n      process.exit(1);\n    }\n  });\n\nif (process.env.NODE_ENV !== 'test') {\n  program.parse();\n}\n\nexport default program;\n","import { z } from 'zod';\nimport type { RuleContext } from '../utils/context';\nimport { findMatchingFiles, isGlobPattern } from '../utils/files';\nimport { AlertLevelSchema } from '../utils/types';\n\nexport const FileContainsOptionsSchema = z.object({\n  path: z.union([z.string(), z.array(z.string()).min(1)]),\n  contains: z.string(),\n  caseSensitive: z.boolean().default(false),\n});\n\nexport const FileContainsSchema = z.object({\n  name: z.literal('file-contains'),\n  level: AlertLevelSchema,\n  options: FileContainsOptionsSchema,\n});\n\nexport type FileContainsOptions = z.input<typeof FileContainsOptionsSchema>;\n\nexport const fileContains = async (\n  context: RuleContext,\n  ruleOptions: FileContainsOptions,\n) => {\n  const errors: string[] = [];\n\n  let sanitizedRuleOptions: z.output<typeof FileContainsOptionsSchema>;\n  try {\n    sanitizedRuleOptions = FileContainsOptionsSchema.parse(ruleOptions);\n  } catch (error) {\n    throw new Error(\n      `Invalid rule options: ${error instanceof Error ? error.message : 'Unknown error'}`,\n    );\n  }\n\n  const { path, contains, caseSensitive } = sanitizedRuleOptions;\n  const paths = Array.isArray(path) ? path : [path];\n\n  const searchText = caseSensitive ? contains : contains.toLowerCase();\n\n  for (const pathPattern of paths) {\n    const isPattern = isGlobPattern(pathPattern);\n    let filesToCheck: string[];\n\n    if (isPattern) {\n      filesToCheck = await findMatchingFiles(context, pathPattern, caseSensitive);\n      if (filesToCheck.length === 0) {\n        errors.push(`${pathPattern}: no files match pattern`);\n        continue;\n      }\n    } else {\n      filesToCheck = [pathPattern];\n    }\n\n    for (const filePath of filesToCheck) {\n      let fileContent: string;\n      try {\n        fileContent = await context.getFileContent(filePath);\n      } catch (error) {\n        errors.push(\n          `${filePath}: ${error instanceof Error ? error.message : 'failed to read file'}`,\n        );\n        continue;\n      }\n\n      const contentToSearch = caseSensitive\n        ? fileContent\n        : fileContent.toLowerCase();\n\n      if (!contentToSearch.includes(searchText)) {\n        errors.push(`${filePath}: file does not contain \"${contains}\"`);\n      }\n    }\n  }\n\n  return { errors };\n};\n","import { minimatch } from \"minimatch\";\nimport { RuleContext } from \"./context\";\n\nexport const isGlobPattern = (path: string): boolean => {\n  return /[*?[\\]{}]/.test(path);\n};\n\nexport const findMatchingFiles = async (\n  context: RuleContext,\n  pattern: string,\n  caseSensitive: boolean,\n): Promise<string[]> => {\n  const allFiles = await context.getAllFiles();\n\n  return allFiles\n    .filter(entry => entry.type === 'file')\n    .filter(entry =>\n      minimatch(entry.path, pattern, {\n        nocase: !caseSensitive,\n        dot: true,\n      }),\n    )\n    .map(entry => entry.path);\n};\n","import { z } from 'zod';\n\nexport const AlertLevelSchema = z.enum(['error', 'warning']);\n","import nodePath from 'node:path';\nimport { minimatch } from 'minimatch';\nimport { z } from 'zod';\nimport { AlertLevelSchema } from '../utils/types';\nimport type { RuleContext } from '../utils/context';\nimport { isGlobPattern } from '../utils/files';\n\nexport const EntryTypeSchema = z.enum(['file', 'directory', 'any']).default('file');\n\nexport const FileExistsOptionsSchema = z.object({\n  caseSensitive: z.boolean().default(false),\n  path: z.union([z.string(), z.array(z.string()).min(1)]),\n  type: EntryTypeSchema,\n});\n\nexport const FileExistsSchema = z.object({\n  name: z.literal('file-exists'),\n  level: AlertLevelSchema,\n  options: FileExistsOptionsSchema,\n});\n\nexport type FileExistsOptions = z.input<typeof FileExistsOptionsSchema>;\n\nconst checkEntryExists = async (\n  context: RuleContext,\n  entryPath: string,\n  caseSensitive: boolean,\n  entryType: 'file' | 'directory' | 'any',\n): Promise<boolean> => {\n  const dirPath = nodePath.dirname(entryPath);\n  const entryName = nodePath.basename(entryPath);\n  const directoryPath = dirPath === '.' ? '' : dirPath;\n\n  let contents;\n  try {\n    contents = await context.getContent(directoryPath);\n  } catch {\n    return false;\n  }\n\n  if (!Array.isArray(contents)) {\n    return false;\n  }\n\n  const entry = contents\n    .filter(item => {\n      if (entryType === 'any') return true;\n      if (entryType === 'file') return item.type === 'file';\n      if (entryType === 'directory') return item.type === 'dir';\n      return false;\n    })\n    .find(item => {\n      return caseSensitive\n        ? item.name === entryName\n        : item.name.toLowerCase() === entryName.toLowerCase();\n    });\n\n  return !!entry;\n};\n\nconst checkPatternExists = async (\n  context: RuleContext,\n  pattern: string,\n  caseSensitive: boolean,\n  entryType: 'file' | 'directory' | 'any',\n): Promise<boolean> => {\n  const allFiles = await context.getAllFiles();\n\n  const matchingEntry = allFiles.find(entry => {\n    if (entryType === 'file' && entry.type !== 'file') return false;\n    if (entryType === 'directory' && entry.type !== 'dir') return false;\n\n    return minimatch(entry.path, pattern, {\n      nocase: !caseSensitive,\n      dot: true,\n    });\n  });\n\n  return !!matchingEntry;\n};\n\nexport const fileExists = async (context: RuleContext, ruleOptions: FileExistsOptions) => {\n  const errors: string[] = [];\n\n  let sanitizedRuleOptions: z.output<typeof FileExistsOptionsSchema>;\n  try {\n    sanitizedRuleOptions = FileExistsOptionsSchema.parse(ruleOptions);\n  } catch (error) {\n    throw new Error(`Invalid rule options: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n\n  const paths = Array.isArray(sanitizedRuleOptions.path)\n    ? sanitizedRuleOptions.path\n    : [sanitizedRuleOptions.path];\n\n  for (const entryPath of paths) {\n    const isPattern = isGlobPattern(entryPath);\n    const exists = isPattern\n      ? await checkPatternExists(context, entryPath, sanitizedRuleOptions.caseSensitive, sanitizedRuleOptions.type)\n      : await checkEntryExists(context, entryPath, sanitizedRuleOptions.caseSensitive, sanitizedRuleOptions.type);\n\n    if (exists) {\n      return { errors };\n    }\n  }\n\n  const pathsDisplay = paths.length === 1 ? paths[0] : `one of [${paths.join(', ')}]`;\n  errors.push(`${pathsDisplay} not found`);\n\n  return { errors };\n};\n","import { minimatch } from 'minimatch';\nimport nodePath from 'node:path';\nimport { z } from 'zod';\nimport type { RuleContext } from '../utils/context';\nimport { isGlobPattern } from '../utils/files';\nimport { AlertLevelSchema } from '../utils/types';\n\nexport const EntryTypeSchema = z.enum(['file', 'directory', 'any']).default('file');\n\nexport const FileForbiddenOptionsSchema = z.object({\n  caseSensitive: z.boolean().default(false),\n  path: z.union([z.string(), z.array(z.string()).min(1)]),\n  type: EntryTypeSchema,\n});\n\nexport const FileForbiddenSchema = z.object({\n  name: z.literal('file-forbidden'),\n  level: AlertLevelSchema,\n  options: FileForbiddenOptionsSchema,\n});\n\nexport type FileForbiddenOptions = z.input<typeof FileForbiddenOptionsSchema>;\n\nconst checkEntryExists = async (\n  context: RuleContext,\n  entryPath: string,\n  caseSensitive: boolean,\n  entryType: 'file' | 'directory' | 'any',\n): Promise<boolean> => {\n  const dirPath = nodePath.dirname(entryPath);\n  const entryName = nodePath.basename(entryPath);\n  const directoryPath = dirPath === '.' ? '' : dirPath;\n\n  let contents;\n  try {\n    contents = await context.getContent(directoryPath);\n  } catch {\n    return false;\n  }\n\n  if (!Array.isArray(contents)) {\n    return false;\n  }\n\n  const entry = contents\n    .filter(item => {\n      if (entryType === 'any') return true;\n      if (entryType === 'file') return item.type === 'file';\n      if (entryType === 'directory') return item.type === 'dir';\n      return false;\n    })\n    .find(item => {\n      return caseSensitive\n        ? item.name === entryName\n        : item.name.toLowerCase() === entryName.toLowerCase();\n    });\n\n  return !!entry;\n};\n\nconst findMatchingEntries = async (\n  context: RuleContext,\n  pattern: string,\n  caseSensitive: boolean,\n  entryType: 'file' | 'directory' | 'any',\n): Promise<string[]> => {\n  const allFiles = await context.getAllFiles();\n\n  return allFiles\n    .filter(entry => {\n      if (entryType === 'file' && entry.type !== 'file') return false;\n      if (entryType === 'directory' && entry.type !== 'dir') return false;\n\n      return minimatch(entry.path, pattern, {\n        nocase: !caseSensitive,\n        dot: true,\n      });\n    })\n    .map(entry => entry.path);\n};\n\nexport const fileForbidden = async (context: RuleContext, ruleOptions: FileForbiddenOptions) => {\n  const errors: string[] = [];\n\n  let sanitizedRuleOptions: z.output<typeof FileForbiddenOptionsSchema>;\n  try {\n    sanitizedRuleOptions = FileForbiddenOptionsSchema.parse(ruleOptions);\n  } catch (error) {\n    throw new Error(`Invalid rule options: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n\n  const paths = Array.isArray(sanitizedRuleOptions.path)\n    ? sanitizedRuleOptions.path\n    : [sanitizedRuleOptions.path];\n\n  const foundEntries: string[] = [];\n\n  for (const entryPath of paths) {\n    const isPattern = isGlobPattern(entryPath);\n\n    if (isPattern) {\n      const matches = await findMatchingEntries(\n        context,\n        entryPath,\n        sanitizedRuleOptions.caseSensitive,\n        sanitizedRuleOptions.type,\n      );\n      foundEntries.push(...matches);\n    } else {\n      const exists = await checkEntryExists(\n        context,\n        entryPath,\n        sanitizedRuleOptions.caseSensitive,\n        sanitizedRuleOptions.type,\n      );\n      if (exists) {\n        foundEntries.push(entryPath);\n      }\n    }\n  }\n\n  if (foundEntries.length > 0) {\n    const uniqueEntries = [...new Set(foundEntries)];\n    const entriesDisplay = uniqueEntries.length === 1\n      ? uniqueEntries[0]\n      : `[${uniqueEntries.join(', ')}]`;\n    errors.push(`${entriesDisplay} should not exist`);\n  }\n\n  return { errors };\n};\n","import { z } from 'zod';\nimport type { RuleContext } from '../utils/context';\nimport { findMatchingFiles, isGlobPattern } from '../utils/files';\nimport { AlertLevelSchema } from '../utils/types';\n\nexport const FileNotContainsOptionsSchema = z.object({\n  path: z.union([z.string(), z.array(z.string()).min(1)]),\n  contains: z.string(),\n  caseSensitive: z.boolean().default(false),\n});\n\nexport const FileNotContainsSchema = z.object({\n  name: z.literal('file-not-contains'),\n  level: AlertLevelSchema,\n  options: FileNotContainsOptionsSchema,\n});\n\nexport type FileNotContainsOptions = z.input<typeof FileNotContainsOptionsSchema>;\n\nexport const fileNotContains = async (\n  context: RuleContext,\n  ruleOptions: FileNotContainsOptions,\n) => {\n  const errors: string[] = [];\n\n  let sanitizedRuleOptions: z.output<typeof FileNotContainsOptionsSchema>;\n  try {\n    sanitizedRuleOptions = FileNotContainsOptionsSchema.parse(ruleOptions);\n  } catch (error) {\n    throw new Error(\n      `Invalid rule options: ${error instanceof Error ? error.message : 'Unknown error'}`,\n    );\n  }\n\n  const { path, contains, caseSensitive } = sanitizedRuleOptions;\n  const paths = Array.isArray(path) ? path : [path];\n\n  const searchText = caseSensitive ? contains : contains.toLowerCase();\n\n  for (const pathPattern of paths) {\n    const isPattern = isGlobPattern(pathPattern);\n    let filesToCheck: string[];\n\n    if (isPattern) {\n      filesToCheck = await findMatchingFiles(context, pathPattern, caseSensitive);\n      if (filesToCheck.length === 0) {\n        continue;\n      }\n    } else {\n      filesToCheck = [pathPattern];\n    }\n\n    for (const filePath of filesToCheck) {\n      let fileContent: string;\n      try {\n        fileContent = await context.getFileContent(filePath);\n      } catch {\n        continue;\n      }\n\n      const contentToSearch = caseSensitive\n        ? fileContent\n        : fileContent.toLowerCase();\n\n      if (contentToSearch.includes(searchText)) {\n        errors.push(`${filePath}: file contains \"${contains}\"`);\n      }\n    }\n  }\n\n  return { errors };\n};\n","import { parse as parseYaml } from 'yaml';\nimport { z } from 'zod';\nimport { AlertLevelSchema } from '../utils/types';\nimport type { RuleContext } from '../utils/context';\n\nexport const GithubActionsTimeoutMinutesOptionsSchema = z.object({\n  maximum: z.number().positive().optional(),\n});\n\nexport const GithubActionsTimeoutMinutesSchema = z.object({\n  name: z.literal('github-actions/timeout-minutes'),\n  level: AlertLevelSchema,\n  options: GithubActionsTimeoutMinutesOptionsSchema.optional(),\n});\n\nexport type GithubActionsTimeoutMinutesOptions = z.input<typeof GithubActionsTimeoutMinutesOptionsSchema>;\n\ninterface WorkflowJob {\n  'timeout-minutes'?: number;\n  [key: string]: unknown;\n}\n\ninterface Workflow {\n  jobs?: Record<string, WorkflowJob>;\n  [key: string]: unknown;\n}\n\nexport const githubActionsTimeoutMinutes = async (\n  context: RuleContext,\n  ruleOptions: GithubActionsTimeoutMinutesOptions = {},\n) => {\n  const errors: string[] = [];\n  const workflowsPath = '.github/workflows';\n\n  let workflowFiles;\n  try {\n    const contents = await context.getContent(workflowsPath);\n    if (!Array.isArray(contents)) {\n      return { errors };\n    }\n    workflowFiles = contents.filter(\n      (item) =>\n        item.type === 'file' &&\n        (item.name.endsWith('.yml') || item.name.endsWith('.yaml')),\n    );\n  } catch {\n    return { errors };\n  }\n\n  for (const file of workflowFiles) {\n    const filePath = `${workflowsPath}/${file.name}`;\n    let content: string;\n\n    try {\n      content = await context.getFileContent(filePath);\n    } catch (error) {\n      errors.push(\n        `${filePath}: failed to read file: ${error instanceof Error ? error.message : 'Unknown error'}`,\n      );\n      continue;\n    }\n\n    let workflow: Workflow;\n    try {\n      workflow = parseYaml(content) as Workflow;\n    } catch (error) {\n      errors.push(\n        `${filePath}: failed to parse YAML: ${error instanceof Error ? error.message : 'Unknown error'}`,\n      );\n      continue;\n    }\n\n    if (workflow?.jobs) {\n      for (const jobName of Object.keys(workflow.jobs)) {\n        const job = workflow.jobs[jobName];\n        const timeoutMinutes = job?.['timeout-minutes'];\n        if (timeoutMinutes === undefined) {\n          errors.push(`${filePath}: job \"${jobName}\" is missing timeout-minutes`);\n        } else if (\n          ruleOptions.maximum !== undefined &&\n          timeoutMinutes > ruleOptions.maximum\n        ) {\n          errors.push(\n            `${filePath}: job \"${jobName}\" has timeout-minutes (${timeoutMinutes}) that is higher than ${ruleOptions.maximum}`,\n          );\n        }\n      }\n    }\n  }\n\n  return { errors };\n};\n","import { z } from 'zod';\nimport { fileExists } from './file-exists';\nimport { AlertLevelSchema } from '../utils/types';\nimport type { RuleContext } from '../utils/context';\n\nexport const LicenseExistsOptionsSchema = z.object({\n  caseSensitive: z.boolean().default(false),\n  path: z.union([z.string(), z.array(z.string()).min(1)]).default('LICENSE.md'),\n});\n\nexport const LicenseExistsSchema = z.object({\n  name: z.literal('license/exists'),\n  level: AlertLevelSchema,\n  options: LicenseExistsOptionsSchema,\n});\n\nexport type LicenseExistsOptions = z.input<typeof LicenseExistsOptionsSchema>;\n\nexport const licenseExists = async (context: RuleContext, ruleOptions: LicenseExistsOptions) => {\n  let sanitizedRuleOptions: z.output<typeof LicenseExistsOptionsSchema>;\n  try {\n    sanitizedRuleOptions = LicenseExistsOptionsSchema.parse(ruleOptions);\n  } catch (error) {\n    throw new Error(`Invalid rule options: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n  const { errors } = await fileExists(context, sanitizedRuleOptions);\n  return { errors };\n};\n","import { parse as parseToml } from 'smol-toml';\nimport { z } from 'zod';\nimport type { RuleContext } from '../utils/context';\nimport { AlertLevelSchema } from '../utils/types';\n\nexport const PyprojectDependenciesAlphabeticalOrderOptionsSchema = z.object({\n  path: z.string().default('pyproject.toml'),\n  sections: z\n    .array(z.string())\n    .default(['project.dependencies', 'project.optional-dependencies', 'tool.poetry.dependencies']),\n});\n\nexport const PyprojectDependenciesAlphabeticalOrderSchema = z.object({\n  name: z.literal('python/pyproject-dependencies-alphabetical-order'),\n  level: AlertLevelSchema,\n  options: PyprojectDependenciesAlphabeticalOrderOptionsSchema.optional(),\n});\n\nexport type PyprojectDependenciesAlphabeticalOrderOptions = z.input<\n  typeof PyprojectDependenciesAlphabeticalOrderOptionsSchema\n>;\n\ninterface PyprojectToml {\n  project?: {\n    dependencies?: string[];\n    'optional-dependencies'?: Record<string, string[]>;\n    [key: string]: unknown;\n  };\n  tool?: {\n    poetry?: {\n      dependencies?: Record<string, unknown>;\n      [key: string]: unknown;\n    };\n    [key: string]: unknown;\n  };\n  [key: string]: unknown;\n}\n\nconst getDependencyName = (dep: string): string => {\n  const match = dep.match(/^([a-zA-Z0-9_-]+(?:\\[[^\\]]+\\])?)/);\n  return match ? match[1].toLowerCase() : dep.toLowerCase();\n};\n\nconst checkAlphabeticalOrder = (dependencies: string[], sectionPath: string): string[] => {\n  const errors: string[] = [];\n  const sorted = [...dependencies].sort((a, b) => {\n    const nameA = getDependencyName(a);\n    const nameB = getDependencyName(b);\n    return nameA.localeCompare(nameB);\n  });\n\n  for (let i = 0; i < dependencies.length; i++) {\n    if (dependencies[i] !== sorted[i]) {\n      errors.push(\n        `${sectionPath}: dependencies are not in alphabetical order. Expected \"${sorted[i]}\" but found \"${dependencies[i]}\"`,\n      );\n      break;\n    }\n  }\n\n  return errors;\n};\n\nconst getNestedValue = (obj: unknown, path: string): unknown => {\n  const parts = path.split('.');\n  let current: unknown = obj;\n  for (const part of parts) {\n    if (current && typeof current === 'object' && part in current) {\n      current = (current as Record<string, unknown>)[part];\n    } else {\n      return undefined;\n    }\n  }\n  return current;\n};\n\nexport const pyprojectDependenciesAlphabeticalOrder = async (\n  context: RuleContext,\n  ruleOptions: PyprojectDependenciesAlphabeticalOrderOptions = {},\n) => {\n  const errors: string[] = [];\n\n  let sanitizedRuleOptions: z.output<typeof PyprojectDependenciesAlphabeticalOrderOptionsSchema>;\n  try {\n    sanitizedRuleOptions = PyprojectDependenciesAlphabeticalOrderOptionsSchema.parse(ruleOptions);\n  } catch (error) {\n    throw new Error(\n      `Invalid rule options: ${error instanceof Error ? error.message : 'Unknown error'}`,\n    );\n  }\n\n  const { path, sections } = sanitizedRuleOptions;\n\n  let content: string;\n  try {\n    content = await context.getFileContent(path);\n  } catch (error) {\n    errors.push(\n      `${path}: ${error instanceof Error ? error.message : 'failed to read file'}`,\n    );\n    return { errors };\n  }\n\n  let pyproject: PyprojectToml;\n  try {\n    pyproject = parseToml(content) as PyprojectToml;\n  } catch (error) {\n    errors.push(\n      `${path}: failed to parse TOML: ${error instanceof Error ? error.message : 'Unknown error'}`,\n    );\n    return { errors };\n  }\n\n  for (const sectionPath of sections) {\n    const sectionValue = getNestedValue(pyproject, sectionPath);\n\n    if (sectionValue === undefined) {\n      continue;\n    }\n\n    if (sectionPath === 'project.dependencies') {\n      if (Array.isArray(sectionValue)) {\n        const deps = sectionValue as string[];\n        if (deps.length > 0) {\n          errors.push(...checkAlphabeticalOrder(deps, `${path}:${sectionPath}`));\n        }\n      }\n    } else if (sectionPath === 'project.optional-dependencies') {\n      if (sectionValue && typeof sectionValue === 'object') {\n        const optionalDeps = sectionValue as Record<string, string[]>;\n        for (const [groupName, deps] of Object.entries(optionalDeps)) {\n          if (Array.isArray(deps) && deps.length > 0) {\n            errors.push(\n              ...checkAlphabeticalOrder(deps, `${path}:${sectionPath}.${groupName}`),\n            );\n          }\n        }\n      }\n    } else if (sectionPath === 'tool.poetry.dependencies') {\n      if (sectionValue && typeof sectionValue === 'object') {\n        const poetryDeps = sectionValue as Record<string, unknown>;\n        const depNames = Object.keys(poetryDeps).filter(\n          (key) => key !== 'python',\n        );\n        if (depNames.length > 0) {\n          const sorted = [...depNames].sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));\n          for (let i = 0; i < depNames.length; i++) {\n            if (depNames[i] !== sorted[i]) {\n              errors.push(\n                `${path}:${sectionPath}: dependencies are not in alphabetical order. Expected \"${sorted[i]}\" but found \"${depNames[i]}\"`,\n              );\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return { errors };\n};\n","import { z } from 'zod';\nimport { fileExists } from './file-exists';\nimport { AlertLevelSchema } from '../utils/types';\nimport type { RuleContext } from '../utils/context';\n\nexport const ReadmeExistsOptionsSchema = z.object({\n  caseSensitive: z.boolean().optional().default(false),\n  path: z.union([z.string(), z.array(z.string()).min(1)]).optional().default('README.md'),\n});\n\nexport const ReadmeExistsSchema = z.object({\n  name: z.literal('readme/exists'),\n  level: AlertLevelSchema,\n  options: ReadmeExistsOptionsSchema,\n});\n\nexport type ReadmeExistsOptions = z.input<typeof ReadmeExistsOptionsSchema>;\n\nexport const readmeExists = async (context: RuleContext, ruleOptions: ReadmeExistsOptions) => {\n  let sanitizedRuleOptions: z.output<typeof ReadmeExistsOptionsSchema>;\n  try {\n    sanitizedRuleOptions = ReadmeExistsOptionsSchema.parse(ruleOptions);\n  } catch (error) {\n    throw new Error(`Invalid rule options: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n  const { errors } = await fileExists(context, sanitizedRuleOptions);\n  return { errors };\n};\n","import { z } from 'zod';\nimport type { RuleContext } from '../utils/context';\nimport { getDependencyName, parseRequirementsFile } from '../utils/python/requirements';\nimport { AlertLevelSchema } from '../utils/types';\n\nexport const RequirementsTxtDependenciesAlphabeticalOrderOptionsSchema = z.object({\n  path: z.string().default('requirements.txt'),\n});\n\nexport const RequirementsTxtDependenciesAlphabeticalOrderSchema = z.object({\n  name: z.literal('python/requirements-txt-dependencies-alphabetical-order'),\n  level: AlertLevelSchema,\n  options: RequirementsTxtDependenciesAlphabeticalOrderOptionsSchema.optional(),\n});\n\nexport type RequirementsTxtDependenciesAlphabeticalOrderOptions = z.input<\n  typeof RequirementsTxtDependenciesAlphabeticalOrderOptionsSchema\n>;\n\nconst checkAlphabeticalOrder = (dependencies: string[], filePath: string): string[] => {\n  const errors: string[] = [];\n  const sorted = [...dependencies].sort((a, b) => {\n    const nameA = getDependencyName(a);\n    const nameB = getDependencyName(b);\n    return nameA.localeCompare(nameB);\n  });\n\n  for (let i = 0; i < dependencies.length; i++) {\n    if (dependencies[i] !== sorted[i]) {\n      errors.push(\n        `${filePath}: dependencies are not in alphabetical order. Expected \"${sorted[i]}\" but found \"${dependencies[i]}\"`,\n      );\n      break;\n    }\n  }\n  return errors;\n};\n\nexport const requirementsTxtDependenciesAlphabeticalOrder = async (\n  context: RuleContext,\n  ruleOptions: RequirementsTxtDependenciesAlphabeticalOrderOptions = {},\n) => {\n  const errors: string[] = [];\n\n  let sanitizedRuleOptions: z.output<typeof RequirementsTxtDependenciesAlphabeticalOrderOptionsSchema>;\n  try {\n    sanitizedRuleOptions = RequirementsTxtDependenciesAlphabeticalOrderOptionsSchema.parse(ruleOptions);\n  } catch (error) {\n    throw new Error(\n      `Invalid rule options: ${error instanceof Error ? error.message : 'Unknown error'}`,\n    );\n  }\n\n  const { path } = sanitizedRuleOptions;\n\n  let content: string;\n  try {\n    content = await context.getFileContent(path);\n  } catch (error) {\n    errors.push(\n      `${path}: ${error instanceof Error ? error.message : 'failed to read file'}`,\n    );\n    return { errors };\n  }\n\n  const dependencies = parseRequirementsFile(content);\n  if (dependencies.length === 0) {\n    return { errors };\n  }\n  errors.push(...checkAlphabeticalOrder(dependencies, path));\n  return { errors };\n};\n","\nconst extractPackageNameFromUrl = (url: string): string => {\n  const eggMatch = url.match(/#egg=([a-zA-Z0-9_-]+)/);\n  if (eggMatch) {\n    return eggMatch[1].toLowerCase();\n  }\n\n  const urlMatch = url.match(/(?:github\\.com|gitlab\\.com|bitbucket\\.org)[/:]([^/]+)\\/([^/]+?)(?:\\.git|@|#|$)/);\n  if (urlMatch) {\n    return urlMatch[2].toLowerCase();\n  }\n\n  return url.toLowerCase();\n};\n\nexport const getDependencyName = (line: string): string => {\n  const trimmed = line.trim();\n\n  // Editable installs (-e . or -e ./local-package)\n  if (trimmed.startsWith('-e ')) {\n    const rest = trimmed.slice(3).trim();\n    if (rest.startsWith('.') || rest.startsWith('/')) {\n      const parts = rest.split(/[/\\\\]/);\n      const lastPart = parts[parts.length - 1];\n      return lastPart.toLowerCase();\n    }\n    return extractPackageNameFromUrl(rest);\n  }\n\n  // git URLs: git+https://..., git+ssh://..., etc.\n  if (trimmed.includes('git+') || trimmed.includes('@git+')) {\n    return extractPackageNameFromUrl(trimmed);\n  }\n\n  // File paths: ./local-package or /path/to/package\n  if (trimmed.startsWith('.') || trimmed.startsWith('/')) {\n    const parts = trimmed.split(/[/\\\\]/);\n    const lastPart = parts[parts.length - 1];\n    return lastPart.toLowerCase();\n  }\n\n  // Standard format: package, package==1.0.0, package>=1.0.0, package[extra]>=1.0.0\n  const match = trimmed.match(/^([a-zA-Z0-9_-]+(?:\\[[^\\]]+\\])?)/);\n  return match ? match[1].toLowerCase() : trimmed.toLowerCase();\n};\n\nexport const parseRequirementsFile = (content: string): string[] => {\n  const lines = content.split('\\n');\n  const dependencies: string[] = [];\n\n  for (const line of lines) {\n    const trimmed = line.trim();\n\n    if (trimmed === '' || trimmed.startsWith('#')) {\n      continue;\n    }\n\n    const commentIndex = trimmed.indexOf('#');\n    const lineContent = commentIndex >= 0 ? trimmed.slice(0, commentIndex).trim() : trimmed;\n\n    if (lineContent === '') {\n      continue;\n    }\n\n    dependencies.push(lineContent);\n  }\n  return dependencies;\n};\n","import { fileContains } from \"./rules/file-contains\";\nimport { fileExists } from \"./rules/file-exists\";\nimport { fileForbidden } from \"./rules/file-forbidden\";\nimport { fileNotContains } from \"./rules/file-not-contains\";\nimport { githubActionsTimeoutMinutes } from \"./rules/github-actions-timeout-minutes\";\nimport { licenseExists } from \"./rules/license-exists\";\nimport { pyprojectDependenciesAlphabeticalOrder } from \"./rules/pyproject-dependencies-alphabetical-order\";\nimport { readmeExists } from \"./rules/readme-exists\";\nimport { requirementsTxtDependenciesAlphabeticalOrder } from \"./rules/requirements-txt-dependencies-alphabetical-order\";\n\nexport const rulesMapper = {\n  'file-contains': fileContains,\n  'file-exists': fileExists,\n  'file-forbidden': fileForbidden,\n  'file-not-contains': fileNotContains,\n  'github-actions/timeout-minutes': githubActionsTimeoutMinutes,\n  'license/exists': licenseExists,\n  'python/pyproject-dependencies-alphabetical-order': pyprojectDependenciesAlphabeticalOrder,\n  'python/requirements-txt-dependencies-alphabetical-order': requirementsTxtDependenciesAlphabeticalOrder,\n  'readme/exists': readmeExists,\n};\n","import type { getOctokit } from '@actions/github';\nimport type { RestEndpointMethodTypes } from '@octokit/plugin-rest-endpoint-methods';\n\nexport type Octokit = ReturnType<typeof getOctokit>;\nexport type Repository = RestEndpointMethodTypes['repos']['listForAuthenticatedUser']['response']['data'][number];\nexport type RepoContent = RestEndpointMethodTypes['repos']['getContent']['response']['data'];\n\nexport interface FileEntry {\n  path: string;\n  name: string;\n  type: 'file' | 'dir';\n}\n\nexport class RuleContext {\n  private contentCache: Map<string, RepoContent> = new Map();\n  private fileContentCache: Map<string, string> = new Map();\n  private allFilesCache: FileEntry[] | null = null;\n\n  constructor(\n    public readonly octokit: Octokit,\n    public readonly repository: Repository,\n  ) {}\n\n  async getContent(path: string = ''): Promise<RepoContent> {\n    const cacheKey = `${this.repository.full_name}:${path}`;\n\n    if (this.contentCache.has(cacheKey)) {\n      return this.contentCache.get(cacheKey)!;\n    }\n\n    const { data: contents } = await this.octokit.rest.repos.getContent({\n      owner: this.repository.owner.login,\n      repo: this.repository.name,\n      path,\n    });\n\n    this.contentCache.set(cacheKey, contents);\n    return contents;\n  }\n\n  async getAllFiles(): Promise<FileEntry[]> {\n    if (this.allFilesCache !== null) {\n      return this.allFilesCache;\n    }\n\n    const files: FileEntry[] = [];\n    const dirsToProcess: string[] = [''];\n\n    while (dirsToProcess.length > 0) {\n      const dir = dirsToProcess.pop()!;\n      const contents = await this.getContent(dir);\n      if (Array.isArray(contents)) {\n        for (const item of contents) {\n          const itemPath = dir ? `${dir}/${item.name}` : item.name;\n          if (item.type === 'file') {\n            files.push({ path: itemPath, name: item.name, type: 'file' });\n          } else if (item.type === 'dir') {\n            files.push({ path: itemPath, name: item.name, type: 'dir' });\n            dirsToProcess.push(itemPath);\n          }\n        }\n      }\n    }\n\n    this.allFilesCache = files;\n    return files;\n  }\n\n  async getFileContent(path: string): Promise<string> {\n    const cacheKey = `${this.repository.full_name}:file:${path}`;\n\n    if (this.fileContentCache.has(cacheKey)) {\n      return this.fileContentCache.get(cacheKey)!;\n    }\n\n    const content = await this.getContent(path);\n\n    if (Array.isArray(content)) {\n      throw new Error(`Path ${path} is a directory, not a file`);\n    }\n\n    if (content.type !== 'file' || !('content' in content)) {\n      throw new Error(`Path ${path} is not a file`);\n    }\n\n    const decodedContent = Buffer.from(content.content, 'base64').toString('utf-8');\n    this.fileContentCache.set(cacheKey, decodedContent);\n    return decodedContent;\n  }\n\n  clearCache(): void {\n    this.contentCache.clear();\n    this.fileContentCache.clear();\n    this.allFilesCache = null;\n  }\n}\n","import { createJiti } from 'jiti';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport { z } from 'zod';\nimport { rulesConfigSchema } from '../rules';\n\nconst regexPatternSchema = z.string().refine(\n  (pattern) => {\n    try {\n      new RegExp(pattern);\n      return true;\n    } catch {\n      return false;\n    }\n  },\n  {\n    message: 'Invalid regex pattern',\n  },\n);\n\nconst filtersSchema = z.object({\n  archived: z.boolean().optional(),\n  organizations: z.array(z.string()).optional(),\n  visibility: z.enum(['public', 'private', 'all']).optional(),\n  include: z.array(regexPatternSchema).optional(),\n  exclude: z.array(regexPatternSchema).optional(),\n});\n\nexport const configSchema = z.object({\n  rules: rulesConfigSchema.optional().default([]),\n  filters: filtersSchema.optional(),\n});\n\nexport type Config = z.infer<typeof configSchema>;\n\nconst CONFIG_FILES = [\n  'repofmt.config.ts',\n  'repofmt.config.js',\n  'repofmt.config.mjs',\n  'repofmt.config.cjs',\n];\n\nexport const getConfig = async (configPathArg?: string): Promise<Config> => {\n  let configPath: string | undefined;\n\n  if (configPathArg) {\n    const resolvedPath = path.isAbsolute(configPathArg)\n      ? configPathArg\n      : path.join(process.cwd(), configPathArg);\n    if (!fs.existsSync(resolvedPath)) {\n      throw new Error(`Config file not found: ${configPathArg}`);\n    }\n    configPath = resolvedPath;\n  } else {\n    const workspaceRoot = process.cwd();\n    for (const configFile of CONFIG_FILES) {\n      const candidatePath = path.join(workspaceRoot, configFile);\n      if (fs.existsSync(candidatePath)) {\n        configPath = candidatePath;\n        break;\n      }\n    }\n\n    if (!configPath) {\n      throw new Error(\n        `No config file found. Create one of: ${CONFIG_FILES.join(', ')}`,\n      );\n    }\n  }\n\n  console.info(`Found config at ${configPath}`);\n\n  const jiti = createJiti(pathToFileURL(__filename).href);\n  const configModule = await jiti.import(configPath);\n  const rawConfig = (configModule as { default?: unknown }).default ?? configModule;\n\n  const result = configSchema.safeParse(rawConfig);\n  if (!result.success) {\n    throw new Error(`Invalid config: ${result.error.message}`);\n  }\n\n  return result.data;\n};\n","import z from 'zod';\nimport { FileContainsSchema } from './file-contains';\nimport { FileExistsSchema } from './file-exists';\nimport { FileForbiddenSchema } from './file-forbidden';\nimport { FileNotContainsSchema } from './file-not-contains';\nimport { GithubActionsTimeoutMinutesSchema } from './github-actions-timeout-minutes';\nimport { LicenseExistsSchema } from './license-exists';\nimport { PyprojectDependenciesAlphabeticalOrderSchema } from './pyproject-dependencies-alphabetical-order';\nimport { ReadmeExistsSchema } from './readme-exists';\nimport { RequirementsTxtDependenciesAlphabeticalOrderSchema } from './requirements-txt-dependencies-alphabetical-order';\n\nexport const ruleConfigSchema = z.union([\n  FileContainsSchema,\n  FileNotContainsSchema,\n  FileExistsSchema,\n  FileForbiddenSchema,\n  GithubActionsTimeoutMinutesSchema,\n  LicenseExistsSchema,\n  PyprojectDependenciesAlphabeticalOrderSchema,\n  ReadmeExistsSchema,\n  RequirementsTxtDependenciesAlphabeticalOrderSchema,\n]);\n\nexport const rulesConfigSchema = z.array(ruleConfigSchema);\n\nexport type RulesConfig = z.infer<typeof rulesConfigSchema>;\n","import type { getOctokit } from '@actions/github';\nimport type { RestEndpointMethodTypes } from '@octokit/plugin-rest-endpoint-methods';\nimport { rulesMapper } from './rulesMapper';\nimport { Config } from './utils/config';\nimport { RuleContext } from './utils/context';\n\nexport { fileContains } from './rules/file-contains';\nexport { fileExists } from './rules/file-exists';\nexport { fileForbidden } from './rules/file-forbidden';\nexport { fileNotContains } from './rules/file-not-contains';\nexport { githubActionsTimeoutMinutes } from './rules/github-actions-timeout-minutes';\nexport { licenseExists } from './rules/license-exists';\nexport { pyprojectDependenciesAlphabeticalOrder } from './rules/pyproject-dependencies-alphabetical-order';\nexport { readmeExists } from './rules/readme-exists';\nexport { requirementsTxtDependenciesAlphabeticalOrder } from './rules/requirements-txt-dependencies-alphabetical-order';\nexport { rulesMapper } from './rulesMapper';\nexport { configSchema, getConfig, type Config } from './utils/config';\nexport { RuleContext } from './utils/context';\n\nexport type Octokit = ReturnType<typeof getOctokit>;\nexport type Repository = RestEndpointMethodTypes['repos']['listForAuthenticatedUser']['response']['data'][number];\n\nexport interface RunResult {\n  repository: string;\n  results: {\n    rule: string;\n    errors?: string[];\n    warnings?: string[];\n  }[];\n}\n\nexport async function runRulesForRepo(\n  octokit: Octokit,\n  repo: Repository,\n  config: Config,\n): Promise<RunResult> {\n  const results: RunResult['results'] = [];\n  const context = new RuleContext(octokit, repo);\n\n  for (const ruleConfig of config.rules ?? []) {\n    const { name: rule, level: alertLevel, options: ruleOptions } = ruleConfig;\n    const ruleFunction = rulesMapper[rule as keyof typeof rulesMapper];\n    if (!ruleFunction) {\n      throw new Error(`Rule ${rule} not found`);\n    }\n    const { errors } = await ruleFunction(context, ruleOptions as never);\n    if (errors.length > 0) {\n      if (alertLevel === 'error') {\n        results.push({ rule, errors });\n      } else if (alertLevel === 'warning') {\n        results.push({ rule, warnings: errors });\n      }\n    }\n  }\n\n  return {\n    repository: repo.full_name,\n    results,\n  };\n}\n\nfunction matchesFilters(repo: Repository, filters?: Config['filters']): boolean {\n  if (!filters) {\n    return true;\n  }\n\n  if (filters.visibility) {\n    if (filters.visibility === 'public' && repo.private) {\n      return false;\n    }\n    if (filters.visibility === 'private' && !repo.private) {\n      return false;\n    }\n  }\n\n  if (filters.archived !== undefined) {\n    if (filters.archived && !repo.archived) {\n      return false;\n    }\n    if (!filters.archived && repo.archived) {\n      return false;\n    }\n  }\n\n  if (filters.organizations && filters.organizations.length > 0) {\n    if (!filters.organizations.includes(repo.owner.login)) {\n      return false;\n    }\n  }\n\n  if (filters.include && filters.include.length > 0) {\n    let matched = false;\n    for (const pattern of filters.include) {\n      const regex = new RegExp(pattern);\n      if (regex.test(repo.name) || regex.test(repo.full_name)) {\n        matched = true;\n        break;\n      }\n    }\n    if (!matched) {\n      return false;\n    }\n  }\n\n  if (filters.exclude && filters.exclude.length > 0) {\n    for (const pattern of filters.exclude) {\n      const regex = new RegExp(pattern);\n      if (regex.test(repo.name) || regex.test(repo.full_name)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nexport async function run(\n  octokit: Octokit,\n  config: Config,\n): Promise<RunResult[]> {\n  const visibility = config.filters?.visibility ?? 'all';\n  const { data: repos } = await octokit.rest.repos.listForAuthenticatedUser({\n    visibility,\n    per_page: 100,\n  });\n\n  const results: RunResult[] = [];\n\n  for (const repo of repos) {\n    if (matchesFilters(repo, config.filters)) {\n      const repoResult = await runRulesForRepo(octokit, repo, config);\n      results.push(repoResult);\n    }\n  }\n\n  return results;\n}\n"],"mappings":"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","names":["import_node_path","import_zod","path","path","import_minimatch","import_zod","nodePath","import_minimatch","import_node_path","import_zod","EntryTypeSchema","checkEntryExists","nodePath","import_zod","path","import_zod","parseYaml","import_zod","import_zod","path","parseToml","import_zod","import_zod","getDependencyName","checkAlphabeticalOrder","getDependencyName","path","path","import_zod","import_zod","z"]}