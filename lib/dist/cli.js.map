{"version":3,"sources":["../src/cli.ts","../src/rules/file-exists.ts","../src/rules/license-exists.ts","../src/rules/readme-exists.ts","../src/rulesMapper.ts","../src/utils/config.ts","../src/rules/index.ts","../src/index.ts"],"sourcesContent":["#!/usr/bin/env node\n\nimport { Command } from 'commander';\nimport { readFileSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { getOctokit } from '@actions/github';\nimport { getConfig, run } from './index';\n\nconst packageJson = JSON.parse(\n  readFileSync(join(__dirname, '../package.json'), 'utf-8'),\n);\n\nconst program = new Command();\n\nprogram\n  .name('repolint')\n  .description('A CLI tool that checks consistency across repositories')\n  .version(packageJson.version);\n\nprogram\n  .command('run')\n  .description('Run repolint checks against your repositories')\n  .option('--config <path>', 'path to config file')\n  .option('--token <token>', 'GitHub token (can also use GITHUB_TOKEN env var)')\n  .action(async (options) => {\n    console.log('Running repolint...');\n\n    let config;\n    try {\n      config = await getConfig(options.config);\n    } catch (error) {\n      console.error(\n        `Configuration error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n      );\n      process.exit(1);\n    }\n\n    const token = options.token ?? process.env.GITHUB_TOKEN;\n    if (!token) {\n      console.error('GitHub token is required. Use --token or set GITHUB_TOKEN environment variable');\n      process.exit(1);\n    }\n\n    const octokit = getOctokit(token);\n\n    try {\n      const results = await run(octokit, config);\n\n      let hasFailures = false;\n      for (const repoResult of results) {\n        console.log(`\\n${repoResult.repository}`);\n        console.log('='.repeat(repoResult.repository.length));\n\n        for (const { rule, passed } of repoResult.results) {\n          const icon = passed ? '✓' : '✗';\n          console.log(`  ${icon} ${rule}`);\n          if (!passed) hasFailures = true;\n        }\n      }\n\n      process.exit(hasFailures ? 1 : 0);\n    } catch (error) {\n      console.error(`Error: ${error instanceof Error ? error.message : 'Unknown error'}`);\n      process.exit(1);\n    }\n  });\n\nif (process.env.NODE_ENV !== 'test') {\n  program.parse();\n}\n\nexport default program;\n","import type { getOctokit } from '@actions/github';\nimport type { RestEndpointMethodTypes } from '@octokit/plugin-rest-endpoint-methods';\nimport { z } from 'zod';\n\nexport const fileExistsOptionsSchema = z.object({\n  caseSensitive: z.boolean().optional().default(false),\n  path: z.string(),\n});\n\nexport type fileExistsOptions = z.infer<typeof fileExistsOptionsSchema>;\n\ntype Octokit = ReturnType<typeof getOctokit>;\ntype Repository = RestEndpointMethodTypes['repos']['listForAuthenticatedUser']['response']['data'][number];\n\nexport const fileExists = async (octokit: Octokit, repository: Repository, ruleOptions: fileExistsOptions) => {\n  const { data: contents } = await octokit.rest.repos.getContent({\n    owner: repository.owner.login,\n    repo: repository.name,\n    path: '',\n  });\n  let sanitizedRuleOptions: fileExistsOptions;\n  try {\n    sanitizedRuleOptions = fileExistsOptionsSchema.parse(ruleOptions);\n  } catch (error) {\n    throw new Error(`Invalid rule options: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n  if (Array.isArray(contents)) {\n    const file = contents\n      .filter(item => item.type === 'file')\n      .find(item => {\n        return sanitizedRuleOptions.caseSensitive\n          ? item.name === sanitizedRuleOptions.path\n          : item.name.toLowerCase() === sanitizedRuleOptions.path.toLowerCase();\n      });\n    return !!file;\n  }\n  return false;\n};\n","import type { getOctokit } from '@actions/github';\nimport type { RestEndpointMethodTypes } from '@octokit/plugin-rest-endpoint-methods';\nimport { z } from 'zod';\nimport { fileExists } from './file-exists';\n\nexport const licenseExistsOptionsSchema = z.object({\n  caseSensitive: z.boolean().optional().default(false),\n  path: z.string().optional().default('LICENSE.md'),\n});\n\nexport type LicenseExistsOptions = z.infer<typeof licenseExistsOptionsSchema>;\n\ntype Octokit = ReturnType<typeof getOctokit>;\ntype Repository = RestEndpointMethodTypes['repos']['listForAuthenticatedUser']['response']['data'][number];\n\nexport const licenseExists = async (octokit: Octokit, repository: Repository, ruleOptions: LicenseExistsOptions) => {\n  let sanitizedRuleOptions: LicenseExistsOptions;\n  try {\n    sanitizedRuleOptions = licenseExistsOptionsSchema.parse(ruleOptions);\n  } catch (error) {\n    throw new Error(`Invalid rule options: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n  return await fileExists(octokit, repository, sanitizedRuleOptions);\n};\n","import type { getOctokit } from '@actions/github';\nimport type { RestEndpointMethodTypes } from '@octokit/plugin-rest-endpoint-methods';\nimport { z } from 'zod';\nimport { fileExists } from './file-exists';\n\nexport const readmeExistsOptionsSchema = z.object({\n  caseSensitive: z.boolean().optional().default(false),\n  path: z.string().optional().default('README.md'),\n});\n\nexport type ReadmeExistsOptions = z.infer<typeof readmeExistsOptionsSchema>;\n\ntype Octokit = ReturnType<typeof getOctokit>;\ntype Repository = RestEndpointMethodTypes['repos']['listForAuthenticatedUser']['response']['data'][number];\n\nexport const readmeExists = async (octokit: Octokit, repository: Repository, ruleOptions: ReadmeExistsOptions) => {\n  let sanitizedRuleOptions: ReadmeExistsOptions;\n  try {\n    sanitizedRuleOptions = readmeExistsOptionsSchema.parse(ruleOptions);\n  } catch (error) {\n    throw new Error(`Invalid rule options: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n  return await fileExists(octokit, repository, sanitizedRuleOptions);\n};\n","import { fileExists } from \"./rules/file-exists\";\nimport { licenseExists } from \"./rules/license-exists\";\nimport { readmeExists } from \"./rules/readme-exists\";\n\nexport const rulesMapper = {\n  'file-exists': fileExists,\n  'license/exists': licenseExists,\n  'readme/exists': readmeExists,\n};\n","import { createJiti } from 'jiti';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport { z } from 'zod';\nimport { ruleConfigSchema } from '../rules';\n\nexport const configSchema = z.object({\n  rules: ruleConfigSchema.optional().default({}),\n});\n\nexport type Config = z.infer<typeof configSchema>;\n\nconst CONFIG_FILES = [\n  'repolint.config.ts',\n  'repolint.config.js',\n  'repolint.config.mjs',\n  'repolint.config.cjs',\n];\n\nexport const getConfig = async (configPathArg?: string): Promise<Config> => {\n  let configPath: string | undefined;\n\n  if (configPathArg) {\n    const resolvedPath = path.isAbsolute(configPathArg)\n      ? configPathArg\n      : path.join(process.cwd(), configPathArg);\n    if (!fs.existsSync(resolvedPath)) {\n      throw new Error(`Config file not found: ${configPathArg}`);\n    }\n    configPath = resolvedPath;\n  } else {\n    const workspaceRoot = process.cwd();\n    for (const configFile of CONFIG_FILES) {\n      const candidatePath = path.join(workspaceRoot, configFile);\n      if (fs.existsSync(candidatePath)) {\n        configPath = candidatePath;\n        break;\n      }\n    }\n\n    if (!configPath) {\n      throw new Error(\n        `No config file found. Create one of: ${CONFIG_FILES.join(', ')}`,\n      );\n    }\n  }\n\n  console.info(`Found config at ${configPath}`);\n\n  const jiti = createJiti(pathToFileURL(__filename).href);\n  const configModule = await jiti.import(configPath);\n  const rawConfig = (configModule as { default?: unknown }).default ?? configModule;\n\n  const result = configSchema.safeParse(rawConfig);\n  if (!result.success) {\n    throw new Error(`Invalid config: ${result.error.message}`);\n  }\n\n  return result.data;\n};\n","import z from 'zod';\nimport { fileExistsOptionsSchema } from './file-exists';\nimport { licenseExistsOptionsSchema } from './license-exists';\nimport { readmeExistsOptionsSchema } from './readme-exists';\n\nexport * from './readme-exists';\n\nexport const ruleConfigSchema = z.object({\n  'file-exists': fileExistsOptionsSchema.optional(),\n  'license/exists': licenseExistsOptionsSchema.optional(),\n  'readme/exists': readmeExistsOptionsSchema.optional(),\n});\n\nexport type RuleConfig = z.infer<typeof ruleConfigSchema>;\nexport type RuleName = keyof RuleConfig;\n","import type { getOctokit } from '@actions/github';\nimport type { RestEndpointMethodTypes } from '@octokit/plugin-rest-endpoint-methods';\nimport { rulesMapper } from './rulesMapper';\nimport { Config } from './utils/config';\n\nexport { getConfig, configSchema, type Config } from './utils/config';\nexport { rulesMapper } from './rulesMapper';\nexport { readmeExists } from './rules/readme-exists';\nexport { licenseExists } from './rules/license-exists';\nexport { fileExists } from './rules/file-exists';\n\nexport type Octokit = ReturnType<typeof getOctokit>;\nexport type Repository = RestEndpointMethodTypes['repos']['listForAuthenticatedUser']['response']['data'][number];\n\nexport interface RepolintResult {\n  repository: string;\n  results: {\n    rule: string;\n    passed: boolean;\n  }[];\n}\n\nexport async function runRulesForRepo(\n  octokit: Octokit,\n  repo: Repository,\n  config: Config,\n): Promise<RepolintResult> {\n  const results: RepolintResult['results'] = [];\n\n  for (const [rule, ruleOptions] of Object.entries(config.rules ?? {})) {\n    const ruleFunction = rulesMapper[rule as keyof typeof rulesMapper];\n    if (!ruleFunction) {\n      throw new Error(`Rule ${rule} not found`);\n    }\n    const passed = await ruleFunction(octokit, repo, ruleOptions);\n    results.push({ rule, passed });\n  }\n\n  return {\n    repository: repo.full_name,\n    results,\n  };\n}\n\nexport async function run(\n  octokit: Octokit,\n  config: Config,\n): Promise<RepolintResult[]> {\n  const { data: repos } = await octokit.rest.repos.listForAuthenticatedUser({\n    visibility: 'all',\n    per_page: 100,\n  });\n\n  const results: RepolintResult[] = [];\n\n  for (const repo of repos) {\n    const repoResult = await runRulesForRepo(octokit, repo, config);\n    results.push(repoResult);\n  }\n\n  return results;\n}\n"],"mappings":"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","names":["import_zod","import_zod","import_zod","import_zod","z"]}